// Cloudflare Pages Function: Proxies ANY URL through Cloudflare edge servers
// Matches /p/https%3A%2F%2Fwww.intel.com (etc.)
export default {
  async fetch(request, env, ctx) {
    let APP_VERSION = '0.0.0';
    const targetParam = ctx && ctx.params && ctx.params.target;
    if (!targetParam) {
      return new Response('Missing target URL', { status: 400 });
    }

    const targetUrl = decodeURIComponent(targetParam);
    try {
      // Try to read the deployed VERSION file so headers reflect the repo VERSION
      try {
        const vres = await fetch(new URL(request.url).origin + '/VERSION');
        if (vres && vres.ok) {
          APP_VERSION = (await vres.text()).trim() || APP_VERSION;
        }
      } catch (e) {}
      // Create proxied request. Build headers carefully â€” don't forward Host or cookies
      const outgoingHeaders = new Headers();
      for (const [k, v] of request.headers) {
        const key = k.toLowerCase();
        // Skip headers that would make the request resolve to our proxy or leak client info
        if (['host', 'cookie', 'content-length'].includes(key)) continue;
        outgoingHeaders.set(k, v);
      }
      // Ensure sensible defaults
      if (!outgoingHeaders.has('user-agent')) {
        outgoingHeaders.set('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
      }
      if (!outgoingHeaders.has('accept')) {
        outgoingHeaders.set('Accept', '*/*');
      }
      outgoingHeaders.set('Referer', targetUrl);

      const proxyReq = new Request(targetUrl, {
        method: request.method,
        headers: outgoingHeaders,
        body: request.body,
        redirect: 'follow',
      });

      const fetched = await fetch(proxyReq);

      const contentType = (fetched.headers.get('Content-Type') || '').toLowerCase();
      if (contentType.startsWith('text/html') || contentType.includes('xml')) {
        // Rewrite HTML/CSS for proxy-relative links using the target site's base
        const proxyBase = new URL(request.url).origin + '/p/';
        const transformed = htmlRewriter(proxyBase, targetUrl).transform(fetched);
        const headers = new Headers(transformed.headers);
        // Remove framing/CSP headers that would prevent embedding
        headers.delete('x-frame-options');
        headers.delete('X-Frame-Options');
        headers.delete('content-security-policy');
        headers.delete('Content-Security-Policy');
        headers.delete('content-security-policy-report-only');
        headers.delete('Content-Security-Policy-Report-Only');
        headers.set('X-App-Version', APP_VERSION);
        headers.set('Access-Control-Allow-Origin', '*');
        return new Response(transformed.body, { status: transformed.status, statusText: transformed.statusText, headers });
      }

      // Other assets (JS/CSS/img): Add CORS + passthrough
      const headers = new Headers(fetched.headers);
      headers.set('Access-Control-Allow-Origin', '*');
      headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
      headers.set('X-App-Version', APP_VERSION);
      headers.delete('X-Frame-Options');
      return new Response(fetched.body, { status: fetched.status, statusText: fetched.statusText, headers });

    } catch (error) {
      return new Response(`Proxy failed: ${error.message}\n\nTarget: ${targetUrl}`, { status: 502 });
    }
  },
};

// HTML Rewriter: Rewrite links/src to proxy
function htmlRewriter(proxyBase, baseUrl) {
  return new HTMLRewriter()
    .on('a[href], link[href], script[src], img[src], source[src], embed[src], iframe[src], form[action]', {
      element(element) {
        let attr = null;
        if (element.tagName === 'form') attr = 'action';
        else if (element.getAttribute('href') !== null) attr = 'href';
        else if (element.getAttribute('src') !== null) attr = 'src';
        if (!attr) return;
        const value = element.getAttribute(attr);
        if (!value) return;
        try {
          const url = new URL(value, baseUrl);
          element.setAttribute(attr, proxyBase + encodeURIComponent(url.href));
        } catch (e) {
          // Ignore invalid URLs
        }
      }
    })
    .on('*[style]', {
      element(element) {
        const style = element.getAttribute('style') || '';
        element.setAttribute('style', rewriteStyleUrls(style, proxyBase, baseUrl));
      }
    })
    // Remove common header/navigation elements to avoid duplicate address bars
    .on('header', {
      element(element) {
        element.remove();
      }
    })
    .on('nav', {
      element(element) {
        element.remove();
      }
    })
    .on('*[role="banner"]', {
      element(element) {
        element.remove();
      }
    })
    .on('*[id], *[class]', {
      element(element) {
        try {
          const id = (element.getAttribute('id') || '').toLowerCase();
          const cls = (element.getAttribute('class') || '').toLowerCase();
          const suspects = ['header', 'topbar', 'navbar', 'masthead', 'toolbar', 'search', 'address', 'banner'];
          for (const s of suspects) {
            if (id.includes(s) || cls.includes(s)) { element.remove(); return; }
          }
        } catch (e) {}
      }
    })
    .on('meta[http-equiv="Content-Security-Policy"]', {
      element(element) {
        element.remove();
      }
    })
    .on('meta[http-equiv="content-security-policy"]', {
      element(element) {
        element.remove();
      }
    })
    .on('base[href]', {
      element(element) {
        element.remove();
      }
    });
}

function rewriteStyleUrls(style, proxyBase, baseUrl) {
  return style.replace(/url\([^)]*\)/g, (match) => {
    const urlMatch = match.match(/url\(["']?([^"')]+)["']?\)/);
    if (urlMatch) {
      try {
        const resolved = new URL(urlMatch[1], baseUrl);
        return `url(${proxyBase}${encodeURIComponent(resolved.href)})`;
      } catch (e) {}
    }
    return match;
  });
}

// No helper needed for base resolution; use `new URL(value, baseUrl)` directly
